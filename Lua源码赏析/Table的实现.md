

## 闭散列
开散列：如C++的std::<unordered_map>，C#的Dictionary<Tkey,TValue>，他们内部有一个数组，放入的元素根据key的hash值算出存储位置，如果两个不同的key拥有同样的hash值，则称为hash冲突，会通过链表或数组的形式将它们串起来。
闭散列：如果发生冲突的时候，不把冲突的键值串起来，而是寻找一个空闲的位置放入新的键值

Lua中的table中关于hash表部分的实现，采用的就是闭散列的算法。
闭散列插入新值的过程如下：
1. 计算key的hash值，算出存储位置
2. 如果当前位置空闲，则插入，算法完成
3. 如果当前位置占用，则使用probing算法，寻找空闲位置
4. 如果找到空闲位置，则插入，算法完成
5. 如果没有找到空闲位置，则先进行扩容和rehash，再从第1步重新开始

其中probing算法有很多种，常见的有：
1. 线性probing：如果冲突发生在i的位置，则搜索序列为：
    - i + 1
    - i + 2
    - i + 3
    - …

2. 二次方式probing：搜索序列为：
    - i + 1
    - i + 2x2
    - i + 3x3
    - …

闭散列查询时的过程如下：
1. 计算key的hash值，算出存储位置
2. 如果当前位置空闲，则没有找到，算法完成
3. 如果当前位置被占用，则检查key值是否相等，如果相等，则返回相应值，算法完成
4. 如果key值不相等，则使用probing算法，寻找下一个位置
5. 如果下一个位置的key值相等，则返5回相应值，算法完成，否则返回步骤4，直到遇到空闲位置，则没有找到，算法完成